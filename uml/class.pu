@startuml class_diagram

namespace gn10_can {

    namespace core {
        struct CANFrame {
            + {static} MAX_DLC : size_t = 8
            + id : uint32_t
            + data : std::array<uint8_t, MAX_DLC>
            + dlc : uint8_t
            + is_extended : bool
            + is_rtr : bool
            + is_error : bool
            + {static} make(type: DeviceType, dev_id: uint8_t, cmd: CmdEnum, payload: uint8_t*, length: size_t) : CANFrame
            + {static} make(type: DeviceType, dev_id: uint8_t, cmd: CmdEnum, payload: std::initializer_list<uint8_t>) : CANFrame
            + set_data(payload: const uint8_t*, length: size_t)
            + operator==(other: const CANFrame&) const : bool
            + operator!=(other: const CANFrame&) const : bool
        }

        class CANBus {
            + {static} MAX_DEVICES : size_t = 16
            - driver_ : drivers.ICanDriver&
            - devices_ : std::array<CANDevice*, MAX_DEVICES>
            - device_count_ : size_t
            + CANBus(driver: drivers.ICanDriver&)
            - attach(device: CANDevice*) : bool
            - detach(device: CANDevice*)
            + update()
            - dispatch(frame: const CANFrame&)
            + send_frame(frame: const CANFrame&) : bool
        }

        abstract class CANDevice {
            - bus_ : CANBus&
            # device_type_ : id.DeviceType
            # device_id_ : uint8_t
            + CANDevice(bus: CANBus&, type: id.DeviceType, id: uint8_t)
            + {abstract} on_receive(frame: CANFrame)
            + get_routing_id() const : uint32_t
            # send(command: CmdEnum, data: const uint8_t*, len: uint8_t) : bool
            # send(command: CmdEnum, data: std::array<uint8_t, N>) : bool
        }
    }

    namespace drivers {
        interface ICanDriver {
            + {abstract} send(frame: core.CANFrame) : bool
            + {abstract} receive(out_frame: core.CANFrame) : bool
        }

        class DriverSTM32CAN {
            - hcan_ : CAN_HandleTypeDef*
            + DriverSTM32CAN(hcan: CAN_HandleTypeDef*)
            + init() : bool
            + send(frame: core.CANFrame) : bool
            + receive(out_frame: core.CANFrame) : bool
        }

        class DriverSTM32FDCAN {
            - hfdcan_ : FDCAN_HandleTypeDef*
            + DriverSTM32FDCAN(hfdcan: FDCAN_HandleTypeDef*)
            + init() : bool
            + send(frame: core.CANFrame) : bool
            + receive(out_frame: core.CANFrame) : bool
        }

        class "DriverAnyPlatform..." as DriverESP32_SocketCAN <<Future>> {
        }

        note "ESP32, SocketCAN(Linux/ROS2), etc..." as Note_DriverESP32_SocketCAN
        Note_DriverESP32_SocketCAN .. DriverESP32_SocketCAN
    }

    namespace devices {
        class MotorDriverClient {
            - feedback_value_ : float
            - limit_switches_ : uint8_t
            - load_current_ : float
            - temperature_ : int8_t
            + MotorDriverClient(bus: core.CANBus&, dev_id: uint8_t)
            + set_init(config: MotorConfig)
            + set_target(target: float)
            + set_gain(type: GainType, value: float)
            + on_receive(frame: core.CANFrame)
            + feedback_value() : float
            + limit_switches() : uint8_t
            + load_current() : float
            + temperature() : int8_t
        }

        class MotorDriverServer {
            - config_ : std::optional<MotorConfig>
            - target_ : std::optional<float>
            - gains_ : std::optional<float>[kGainTypeCount]
            + MotorDriverServer(bus: core.CANBus&, dev_id: uint8_t)
            + send_feedback(feedback_val, limit_switch_state)
            + send_hardware_status(load_current, temperature)
            + get_new_init(config: MotorConfig&) : bool
            + get_new_target(target: float&) : bool
            + get_new_gain(type: GainType, value: float&) : bool
            + on_receive(frame: core.CANFrame)
        }

        class SolenoidDriverClient {
            + SolenoidDriverClient(bus: core.CANBus&, dev_id: uint8_t)
            + set_target(target: bool)
            + on_receive(frame: core.CANFrame)
        }

        class SolenoidDriverServer {
            - target_ : std::optional<bool>
            + SolenoidDriverServer(bus: core.CANBus&, dev_id: uint8_t)
            + get_new_target(target: bool&) : bool
            + on_receive(frame: core.CANFrame)
        }

        class "OtherDevice..." as OtherDevice_SensorHub_ServoDriver <<Future>> {
        }
        
        note "ServoDriver, SensorHub, etc..." as Note_OtherDevice
        Note_OtherDevice .. OtherDevice_SensorHub_ServoDriver

        class MotorConfig {
            + set_max_duty_ratio(ratio: float)
            + get_max_duty_ratio() : float
            + set_accel_ratio(ratio: float)
            + get_accel_ratio() : float
            + set_forward_limit_switch(enable_stop: bool, switch_id: uint8_t)
            + get_forward_limit_switch(enable_stop: bool&, switch_id: uint8_t&)
            + set_reverse_limit_switch(enable_stop: bool, switch_id: uint8_t)
            + get_reverse_limit_switch(enable_stop: bool&, switch_id: uint8_t&)
            + set_feedback_cycle(ms: uint8_t)
            + get_feedback_cycle() : uint8_t
            + set_encoder_type(type: EncoderType)
            + get_encoder_type() : EncoderType
            + set_user_option(option: uint8_t)
            + get_user_option() : uint8_t
            + to_bytes() : std::array<uint8_t, 8>
            + {static} from_bytes(bytes: std::array<uint8_t, 8>) : MotorConfig
            - {static} map_ratio_to_u8(ratio: float) : uint8_t
        }
        
        enum EncoderType {
            None
            IncrementalSpeed
            Absolute
            IncrementalTotal
        }

        enum GainType {
            Kp
            Ki
            Kd
            Ff
            Count
        }
    }
    
    namespace converter {
        class can_converter << (U, #FF7700) Utility >> {
            + {static} pack(buffer: uint8_t*, buffer_len: size_t, start_byte: uint8_t, value: T) : bool
            + {static} unpack(buffer: const uint8_t*, buffer_len: size_t, start_byte: uint8_t, value: T&) : bool
            + {static} pack(buffer: std::array<uint8_t, N>&, start_byte: uint8_t, value: T) : bool
        }
    }

    core.CANBus o-- drivers.ICanDriver
    core.CANBus "1" o-- "0..16" core.CANDevice : manages (RAII) >
    core.CANDevice <|-- devices.MotorDriverClient
    core.CANDevice <|-- devices.MotorDriverServer
    core.CANDevice <|-- devices.SolenoidDriverClient
    core.CANDevice <|-- devices.SolenoidDriverServer
    core.CANDevice <|-- devices.OtherDevice_SensorHub_ServoDriver
    core.CANDevice ..> core.CANBus : attaches to >
    devices.MotorDriverClient ..> devices.MotorConfig : uses >
    devices.MotorDriverServer ..> devices.MotorConfig : uses >
    devices.MotorDriverClient ..> devices.GainType : uses >
    devices.MotorDriverServer ..> devices.GainType : uses >
    devices.MotorConfig ..> devices.EncoderType : uses >

    drivers.ICanDriver <|.. drivers.DriverSTM32CAN
    drivers.ICanDriver <|.. drivers.DriverSTM32FDCAN
    drivers.ICanDriver <|.. drivers.DriverESP32_SocketCAN
}

@enduml
